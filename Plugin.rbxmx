<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXD9AAABAFFDE84DC68B079E4C7F75247C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Plugin</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBXB9C1707012794237A42094D8FB5FE978">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<string name="ScriptGuid">{B7F716F0-A46E-474B-BF44-BF7BBA84F078}</string>
				<ProtectedString name="Source"><![CDATA[--[[

    You may have noticed that I'm running :_Subdivide method twice: once in the CutVisualizer and once in
    Logic module. Not the most efficient way of executing this functionality, and ideally you'd want to cache the stored objects
    from the container and re-parent them to the desired location without having to run :_Subdivide twice.

    With that being said, I've left a possibility to do so by abstracting container logic

    ~vertical alignment gang

]]

local ContextActionService = game:GetService("ContextActionService")
local Selection            = game:GetService("Selection")

local MainFolder           = script.Parent
local ModulesFolder        = MainFolder.MainModules
local UtilFolder           = MainFolder.Util

local Logic                = require(ModulesFolder.Logic)
local CutVisualizer        = require(ModulesFolder.CutVisualizer)
local Maid                 = require(UtilFolder.Maid)
local newMaid              = Maid.new()

local toolbar              = plugin:CreateToolbar("Loop cut Utility")
local newScriptButton      = toolbar:CreateButton("Toggle LoopCut", "Toggles LoopCut on and off", "rbxassetid://7166997540")

--//Plugin action creation (Binding relevant action to keys)
local executeCutAction     = plugin:CreatePluginAction("LoopCut Execute", "Execute LoopCut", "Executes loop-cuts on selection", "rbxassetid://7166997540", true)
local increaseCutsAction   = plugin:CreatePluginAction("LoopCut Increase", "Increase LoopCuts", "Increases number of loop-cuts", "rbxassetid://7166997540", true)
local decreaseCutsAction   = plugin:CreatePluginAction("LoopCut Decrease", "Decrease LoopCuts", "Decreases number of loop-cuts", "rbxassetid://7166997540", true)
local selectXAxisAction    = plugin:CreatePluginAction("LoopCut X", "X Axis Selection", "Sets loop-cuts along X axis of the selected object", "rbxassetid://7166997540", true)
local selectYAxisAction    = plugin:CreatePluginAction("LoopCut Y", "Y Axis Selection", "Sets loop-cuts along Y axis of the selected object", "rbxassetid://7166997540", true)
local selectZAxisAction    = plugin:CreatePluginAction("LoopCut Z", "Z Axis Selection", "Sets loop-cuts along Z axis of the selected object", "rbxassetid://7166997540", true)



local SCROLL_ACTION_NAME   = "Log scroll"
local MOVEMENT_ACTION_NAME = "Log mouse movement"
local isEnabled


local function displayVisuals()
    local selectedObjects = Logic:ValidateSelection()
    if not selectedObjects or #selectedObjects == 0 then
        return
    end

    CutVisualizer:RefreshVisualizer()
    for Index = 1, #selectedObjects do
        local selectedObject = selectedObjects[Index]
        CutVisualizer:VisualizeDivisions(selectedObject, Logic:RetrieveDivisions())
    end
end


local function reset()
    Logic:SetNumOfDivisions(2)
    displayVisuals()
end


local function logAction(actionName, _inputState, inputObject)
    local faceDetected = Logic:DetectFaceAndEdge(inputObject.Position)
    local previousSelectionAxis, currentSelectionAxis = Logic:RetrieveSelectionAxis()

    if actionName == SCROLL_ACTION_NAME then
        Logic:IncrementNumOfDivisions(inputObject.Position.Z)
        displayVisuals()
    elseif actionName == MOVEMENT_ACTION_NAME and faceDetected then
        if previousSelectionAxis == currentSelectionAxis then
            return
        end
        displayVisuals()
    end
end


local function connectActions()
    newMaid:GiveTask(
            executeCutAction.Triggered:Connect(function()
                if Logic:SubdivideSelection() then
                    CutVisualizer:ClearVisualizer()
                    updatePluginStatus(false)
                end
            end)
        )
    newMaid:GiveTask(
            Selection.SelectionChanged:Connect(function()
                local selectedObjects = Logic:ValidateSelection()
                if not selectedObjects or #selectedObjects == 0 then
                    updatePluginStatus(false)
                end
            end)
        )
    newMaid:GiveTask(
            increaseCutsAction.Triggered:Connect(function()
                Logic:IncrementNumOfDivisions(1)
                displayVisuals()
            end)
        )
    newMaid:GiveTask(
            decreaseCutsAction.Triggered:Connect(function()
                Logic:IncrementNumOfDivisions(-1)
                displayVisuals()
            end)
        )
    newMaid:GiveTask(
            selectXAxisAction.Triggered:Connect(function()
                Logic:SetAxisOfAction("X")
                displayVisuals()
            end)
        )
    newMaid:GiveTask(
            selectYAxisAction.Triggered:Connect(function()
                Logic:SetAxisOfAction("Y")
                displayVisuals()
            end)
        )
    newMaid:GiveTask(
            selectZAxisAction.Triggered:Connect(function()
                Logic:SetAxisOfAction("Z")
                displayVisuals()
            end)
        )
end


function updatePluginStatus(status: boolean?)
    if status ~= nil and typeof(status) == "boolean" then
        isEnabled = status
    else
        isEnabled = not isEnabled
    end
    newScriptButton:SetActive(isEnabled)

    if isEnabled then
        reset()
        connectActions()
        ContextActionService:BindAction(SCROLL_ACTION_NAME, logAction, true, Enum.UserInputType.MouseWheel)
        ContextActionService:BindAction(MOVEMENT_ACTION_NAME, logAction, true, Enum.UserInputType.MouseMovement)
    else
        newMaid:DoCleaning()
        CutVisualizer:ClearVisualizer()
        ContextActionService:UnbindAction(SCROLL_ACTION_NAME)
        ContextActionService:UnbindAction(MOVEMENT_ACTION_NAME)
    end
end


newScriptButton.Click:Connect(updatePluginStatus)
updatePluginStatus(false)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX04B9969F7521441DA42D8DA151219635">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">MainModules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX0C9CF05BB8064C4C9F92A31725D4808B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ContainerHandler</string>
					<string name="ScriptGuid">{8D637C26-777B-4E6F-B229-B5BBE763687F}</string>
					<ProtectedString name="Source"><![CDATA[
local ParentFolder              = script.Parent
local MainFolder                = ParentFolder.Parent
local UtilFolder                = MainFolder.Util
local Maid                      = require(UtilFolder.Maid)
local newMaid                   = Maid.new()

local CONTAINER_NAME            = "LoopCut_SelectionBoxes"

--//Intentionally mutable
local containerData = {

    previousSelections = {};
    container = nil;

}


local Container = {}


    function Container:DestroyContainer()
        newMaid:DoCleaning()
        containerData.previousSelections = {}
        if containerData.container == nil then
            return
        end
        containerData.container:Destroy()
        containerData.container = nil
    end


    function Container:ClearContainer()
        if containerData.container == nil then
            return
        end
        containerData.container:ClearAllChildren()
    end


    function Container:CreateContainer()
        containerData.container = Instance.new("Folder")
        containerData.container.Name = CONTAINER_NAME
        containerData.container.Parent = workspace.CurrentCamera
    end


    function Container:ReturnData()
        return containerData
    end


return Container]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC9DA699F1DF1448CB725A6E29E67EDD7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CutVisualizer</string>
					<string name="ScriptGuid">{DA9BC569-A631-4B88-BD14-5071401B62AE}</string>
					<ProtectedString name="Source"><![CDATA[
local ParentFolder              = script.Parent
local MainFolder                = ParentFolder.Parent
local UtilFolder                = MainFolder.Util
local ModulesFolder             = MainFolder.MainModules

local Logic                     = require(ModulesFolder.Logic)
local ContainerHandler          = require(ModulesFolder.ContainerHandler)
local Maid                      = require(UtilFolder.Maid)

local newMaid                   = Maid.new()

local DEFAULT_OUTLINE_THICKNESS = settings().Studio["Line Thickness"]
local DEFAULT_SELECTION_COLOR   = settings().Studio["Select Color"]
local MATH_HUGE                 = math.huge




local Visualizer = {}


    --//Private Methods:

        function Visualizer:_VisualizeCut(Object: BasePart)
            assert(Object ~= nil, "Missing arguments!")

                local selectionBox = Instance.new("SelectionBox")
                selectionBox.Adornee = Object
                selectionBox.LineThickness = DEFAULT_OUTLINE_THICKNESS
                selectionBox.Color3 = DEFAULT_SELECTION_COLOR
                selectionBox.Parent = Object
        end


        function Visualizer:_ApplyVisualizationsIn(Parent)
            for Index = 1, #Parent:GetChildren() do
                local Object = Parent:GetChildren()[Index]
                self:_VisualizeCut(Object)
            end
        end


        function Visualizer:ClearVisualizer()
            newMaid:DoCleaning()
            ContainerHandler:DestroyContainer()
        end


    --//Public Methods:

        function Visualizer:RefreshVisualizer()
            local containerData = ContainerHandler:ReturnData()
            if containerData.container ~= nil then
                ContainerHandler:ClearContainer()
            else
                ContainerHandler:CreateContainer()
            end
        end


        function Visualizer:VisualizeDivisions(obj: BasePart, numOfDivisions: number)
            assert(obj ~= nil and obj:IsA("BasePart"), "Object either nil or of incorrect type!")
            assert(numOfDivisions ~= nil and typeof(numOfDivisions) == "number", "numOfDivisions either nil or of incorrect type!")

            local containerData = ContainerHandler:ReturnData()

            if containerData.previousSelections[obj] == nil then
                newMaid:DoCleaning()
                newMaid:GiveTask(
                    obj.Changed:Connect(function()
                        ContainerHandler:ClearContainer()
                    end)
                )
                containerData.previousSelections[obj] = true
            end

            local partToClone = Instance.new("Part")
            partToClone.Locked = true
            partToClone.Anchored = true
            partToClone.CastShadow = false
            partToClone.CanCollide = false
            partToClone.CanTouch = false
            partToClone.Transparency = 1
            partToClone.Position = Vector3.new(MATH_HUGE, MATH_HUGE, MATH_HUGE)
            partToClone.Parent = containerData.container
            
            Logic:_Subdivide(containerData.container, obj, numOfDivisions, partToClone)
            self:_ApplyVisualizationsIn(containerData.container)
        end


return Visualizer]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX07B6F38346D2461C8C7D7D0DACA5516B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Logic</string>
					<string name="ScriptGuid">{0F51149A-A894-46AD-9EA1-497912477771}</string>
					<ProtectedString name="Source"><![CDATA[--[[

        Credits to the good chap in: https://devforum.roblox.com/t/edge-detection-from-mouse/705054/22
        :_Subdivide method is a bit dirty, if you've got a more elegant solution, feel free to post up!

]]

local Selection                 = game:GetService("Selection")
local ChangeHistoryService      = game:GetService("ChangeHistoryService")

local MIN_DIVISIONS             = 2

local storedVariables = {
    numOfDivisions = MIN_DIVISIONS;
    previousPosition = nil;
    previousSelection = nil;
    previousSelectionAxis = nil;
    selectionAxis = nil;
}



local LogicHandler = {}


    --//Private Methods:

        function LogicHandler:SetAxisOfAction(axis: string)
            storedVariables.previousSelectionAxis = storedVariables.selectionAxis
            storedVariables.selectionAxis = axis
        end


        function LogicHandler:_WhichFaces(part: BasePart, pos: Position, epsilon: number)
            epsilon = epsilon or .5
            pos = part.CFrame:ToObjectSpace(CFrame.new(pos))
            local halfSize = part.Size / 2
            if math.abs(pos.Y) < halfSize.Y + epsilon
                and math.abs(pos.Z) < halfSize.Z + epsilon
                and math.abs(pos.X) < halfSize.X + epsilon
            then
                local faces = {}
                -- check if we're close to an edge
                if pos.Y > halfSize.Y - epsilon then 
                    table.insert(faces, Enum.NormalId.Top) 
                end
                if pos.Y < epsilon - halfSize.Y then 
                    table.insert(faces, Enum.NormalId.Bottom) 
                end

                if pos.Z > halfSize.Z - epsilon then 
                    table.insert(faces, Enum.NormalId.Back) 
                end
                if pos.Z < epsilon - halfSize.Z then 
                    table.insert(faces, Enum.NormalId.Front) 
                end

                if pos.X > halfSize.X - epsilon then 
                    table.insert(faces, Enum.NormalId.Right) 
                end
                if pos.X < epsilon - halfSize.X then 
                    table.insert(faces, Enum.NormalId.Left) 
                end

                return Faces.new(unpack(faces))
            else
                return 
            end
        end


        function LogicHandler:_RaycastFromScreenPoint(mousePos: Vector3, whitelist)
            local camera = workspace.CurrentCamera
            local screenRay = camera:ViewportPointToRay(mousePos.X, mousePos.Y)

            local params = RaycastParams.new()
            params.CollisionGroup = "Default"
            if whitelist then
                params.FilterType = Enum.RaycastFilterType.Whitelist
                params.FilterDescendantsInstances = whitelist
            end

            local result = workspace:Raycast(
                screenRay.Origin, screenRay.Direction * 1000, params
            )

            return result
        end


        function LogicHandler:_GetPositionAndPartFromScreenPoint(pos: Vector3)
            local result = self:_RaycastFromScreenPoint(pos, Selection:Get())

            if not result or result.Instance.Locked then
                result = self:_RaycastFromScreenPoint(pos)

                if not result or result.Instance.Locked then
                    return nil, nil
                end
            end

            local part = result.Instance
            local position = result.Position

            return part, position
        end


    --//Public Methods:

        --//Intended to be semi-private
        function LogicHandler:_Subdivide(Parent, obj: BasePart, divisionNum: number, partToClone: BasePart)
            local axisOfAction = storedVariables.selectionAxis
            if axisOfAction == nil then
                return
            end

            if partToClone == nil then
                partToClone = obj
            end

            local absoluteSize = obj.Size
            local absolutePos = obj.Position
            local absoluteCFrame = obj.CFrame

            local INDIVIDUAL_SIZE = absoluteSize[axisOfAction]/divisionNum
            local STARTING_POS = absolutePos[axisOfAction] - absoluteSize[axisOfAction]/2
            local SIZE_VECTOR

            if axisOfAction == "X" then
                SIZE_VECTOR = Vector3.new(INDIVIDUAL_SIZE, absoluteSize.Y, absoluteSize.Z)
            elseif axisOfAction == "Y" then
                SIZE_VECTOR = Vector3.new(absoluteSize.X, INDIVIDUAL_SIZE, absoluteSize.Z)
            elseif axisOfAction == "Z" then
                SIZE_VECTOR = Vector3.new(absoluteSize.X, absoluteSize.Y, INDIVIDUAL_SIZE)
            end

            for Index = 1, divisionNum do
                local OFFSET = STARTING_POS - INDIVIDUAL_SIZE/2 + INDIVIDUAL_SIZE*Index
                local VECTOR_POSITION

                if axisOfAction == "X" then
                    VECTOR_POSITION = Vector3.new(OFFSET, absolutePos.Y, absolutePos.Z)
                elseif axisOfAction == "Y" then
                    VECTOR_POSITION = Vector3.new(absolutePos.X, OFFSET, absolutePos.Z)
                elseif axisOfAction == "Z" then
                    VECTOR_POSITION = Vector3.new(absolutePos.X, absolutePos.Y, OFFSET)
                end

                --//Convert to object space (For the purpose of applying object's rotation)
                local OBJECT_SPACE = CFrame.new(absolutePos):ToObjectSpace(CFrame.new(VECTOR_POSITION))
                local APPLIED_CFRAME = absoluteCFrame:ToWorldSpace(OBJECT_SPACE)

                local newObj = partToClone:Clone()
                newObj.Parent = Parent
                newObj.Size = SIZE_VECTOR
                newObj.CFrame = APPLIED_CFRAME
            end
        end


        --//In case the responsiveness feels wonky - you may want to fiddle around with this:
        function LogicHandler:DetectFaceAndEdge(mousePos: Vector3)
            local part, position = self:_GetPositionAndPartFromScreenPoint(mousePos)
            if part == nil or position == nil then
                return
            end

            local faces = self:_WhichFaces(part, position)
            if faces.Top or faces.Bottom then
                if faces.Back then
                    self:SetAxisOfAction("Y")
                else
                    self:SetAxisOfAction("X")
                end
            elseif faces.Front or faces.Back then
                self:SetAxisOfAction("Y")
            elseif faces.Right or faces.Left then
                self:SetAxisOfAction("Z")
            end

            storedVariables.previousSelection = part
            storedVariables.previousPosition = position

            return true
        end


        function LogicHandler:SubdivideSelection()
            --local objectToSelect = table.create(storedVariables.numOfDivisions)
            local selectedObjects = self:ValidateSelection()
            if not selectedObjects or #selectedObjects == 0 then
                return
            end

            for Index = 1, #selectedObjects do
                local selectedObject = selectedObjects[Index]
                local model = Instance.new("Model")
                model.Parent = selectedObject.Parent
                self:_Subdivide(model, selectedObject, storedVariables.numOfDivisions)
                selectedObject.Parent = nil
            end

            ChangeHistoryService:SetWaypoint("Subdivision complete")
            return true
        end


        function LogicHandler:ValidateSelection()
            if #Selection:Get() == 0 then
                return
            end

            local selectedObjects = table.create(#Selection:Get())
            for Index = 1, #Selection:Get() do
                local selectedObject = Selection:Get()[Index]
                if selectedObject:IsA("BasePart") then
                    table.insert(selectedObjects, selectedObject)
                end
            end

            return selectedObjects
        end


        function LogicHandler:SetNumOfDivisions(num: number)
            assert(num ~= nil and typeof(num) == "number", "Missing argument or incorrect type!")

            local selectedObj = Selection:Get()[1]
            if selectedObj == nil or not selectedObj:IsA("BasePart") then
                return
            end

            storedVariables.numOfDivisions = math.max(MIN_DIVISIONS, num)
        end


        function LogicHandler:IncrementNumOfDivisions(num: number)
            num += storedVariables.numOfDivisions
            self:SetNumOfDivisions(num)
        end


        function LogicHandler:RetrieveDivisions()
            return storedVariables.numOfDivisions
        end


        function LogicHandler:RetrieveSelectionAxis()
            return storedVariables.previousSelectionAxis, storedVariables.selectionAxis
        end


return LogicHandler]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX356A2584291F4BC5A971BA427B09C460">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Util</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX45302286E7074CB4BB85005C85234504">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Maid</string>
					<string name="ScriptGuid">{80708BDC-058C-48C6-A855-0E520BFFE65E}</string>
					<ProtectedString name="Source"><![CDATA[-- Maid
-- Author: Quenty
-- Source: https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Events/Maid.lua
-- License: MIT (https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md)
-- This module has been modified for use in AeroGameFramework

--[[

	maid = Maid.new()

	maid:GiveTask(task)
		> task is an event connection, function, or instance/table with a 'Destroy' method

	maid:GivePromise(promise)
		> Give the maid a promise as a task, which will call 'promise:Cancel()' on cleanup
	
	maid:DoCleaning()
		> Alias for Destroy
	
	maid:Destroy()
		> Goes through each task & disconnects events, destroys instances, and calls functions

--]]

local Promise = require(script.Parent.Promise)


local Maid = {}
Maid.ClassName = "Maid"


function Maid.new()
	local self = setmetatable({
		_tasks = {};
	}, Maid)
	return self
end


--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if (Maid[index]) then
		return Maid[index]
	else
		return self._tasks[index]
	end
end


--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if (Maid[index] ~= nil) then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]
	tasks[index] = newTask

	if (oldTask) then
		if (type(oldTask) == "function") then
			oldTask()
		elseif (typeof(oldTask) == "RBXScriptConnection") then
			oldTask:Disconnect()
		elseif (oldTask.Destroy) then
			oldTask:Destroy()
		elseif (Promise.Is(oldTask)) then
			oldTask:Cancel()
		end
	end
end


--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = (#self._tasks + 1)
	self[taskId] = task

	if (type(task) == "table" and (not task.Destroy) and (not Promise.Is(task))) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end


function Maid:GivePromise(promise)
	assert(Promise.Is(promise), "Expected promise")
	if (promise:GetStatus() ~= Promise.Status.Started) then
		return promise
	end
	local newPromise = Promise.Resolve(promise)
	local id = self:GiveTask(newPromise)
	newPromise:Finally(function()
		self[id] = nil
	end)
	return newPromise
end


--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if (typeof(task) == "RBXScriptConnection") then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while (task ~= nil) do
		tasks[index] = nil
		if (type(task) == "function") then
			task()
		elseif (typeof(task) == "RBXScriptConnection") then
			task:Disconnect()
		elseif (task.Destroy) then
			task:Destroy()
		elseif (Promise.Is(task)) then
			task:Cancel()
		end
		index, task = next(tasks)
	end
end


--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX38DECE65A17E4ABAA9483FEFE66BE9F5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{5BDCE21D-284C-474C-B8A7-073CD4CA5343}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "No traceback")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end
Promise.Defer = Promise.defer

-- Backwards compatibility
Promise.async = Promise.defer
Promise.Async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end
Promise.Resolve = Promise.resolve

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end
Promise.Reject = Promise.reject

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end
Promise.Try = Promise.try

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount < amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end
Promise.All = Promise.all

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end
Promise.Some = Promise.some

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end
Promise.Any = Promise.any

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end
Promise.AllSettled = Promise.allSettled

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end
Promise.Race = Promise.race

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end
Promise.Each = Promise.each

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end
Promise.Is = Promise.is

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end
Promise.Promisify = Promise.promisify

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
	Promise.Delay = Promise.delay
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end
Promise.prototype.Timeout = Promise.prototype.timeout

function Promise.prototype:getStatus()
	return self._status
end
Promise.prototype.GetStatus = Promise.prototype.getStatus

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end
Promise.prototype.AndThen = Promise.prototype.andThen
Promise.prototype.Then = Promise.prototype.andThen

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end
Promise.prototype.Catch = Promise.prototype.catch

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end
Promise.prototype.Tap = Promise.prototype.tap

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end
Promise.prototype.AndThenCall = Promise.prototype.andThenCall
Promise.prototype.ThenCall = Promise.prototype.andThenCall

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end
Promise.prototype.AndThenReturn = Promise.prototype.andThenReturn
Promise.prototype.ThenReturn = Promise.prototype.andThenReturn

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end
Promise.prototype.Cancel = Promise.prototype.cancel

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end
Promise.prototype.Finally = Promise.prototype.finally

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end
Promise.prototype.FinallyCall = Promise.prototype.finallyCall

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end
Promise.prototype.FinallyReturn = Promise.prototype.finallyReturn

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end
Promise.prototype.Done = Promise.prototype.done

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end
Promise.prototype.DoneCall = Promise.prototype.doneCall

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end
Promise.prototype.DoneReturn = Promise.prototype.doneReturn

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end
Promise.prototype.AwaitStatus = Promise.prototype.awaitStatus

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end
Promise.prototype.Await = Promise.prototype.await

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end
Promise.prototype.Expect = Promise.prototype.expect

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect
Promise.prototype.AwaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility < v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end
Promise.prototype.Now = Promise.prototype.now

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end
Promise.prototype.Retry = Promise.prototype.retry

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end
Promise.FromEvent = Promise.fromEvent

return Promise]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>